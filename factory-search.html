<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>factory-search</title>
<script src="jquery.js"></script>
<script src="factory-data.js"></script>
<script src="lcg.js"></script>
<script src="factory.js"></script>
<script src="damage.js"></script>
<script>
$(function () {
	initialize_factory(function () {
		//main0();
	});
});

function main0() {
	var i = 0;
	function loop() {
		document.title = hex(i);
		while (true) {
			if (i > 0xffffffff) {
				console.log("finish");
				return;
			}
			judge_seed(i ++);
			if ((i & 0xffff) == 0) break;
		}
		setTimeout(loop, 0);
	}
	loop();
}

function judge_seed(seed) {
	var lcg = new LCG(seed);
	var shuu = 5;
	var is_open_level = true;
	var is_hgss = true;
	var trainers = rand_trainers(lcg, shuu, is_hgss);
	var entries = rand_starter_entries(lcg, is_open_level, shuu, 0);
	var mukuho_idx = entries.map(function(x){return x.id}).indexOf(789);
	var rathi_idx = entries.map(function(x){return x.id}).indexOf(933);
	var maji_idx = entries.map(function(x){return x.id}).indexOf(821);
	if (mukuho_idx < 0 || rathi_idx < 0 || maji_idx < 0) return;
	var starters = starter_entiries_to_poke(is_open_level, shuu, 0, entries, rand_pid(lcg, entries));
	var mukuho = starters[mukuho_idx];
	var rathi = starters[rathi_idx];
	var maji = starters[maji_idx];
	var playerPokes = [mukuho, rathi, maji];
	//console.log(playerPokes.map(function(x) x.name));
	lcg.step(2); // shuffle

	var prev;
	for (var i = 1; i <= 7; i ++) {
		var seen = i == 1 ? starters : playerPokes.concat(prev);
		var rank = trainer_id_to_rank(is_open_level, is_hgss, trainers[i-1]);
		var pokes = rand_enemy_poke(lcg, rank, seen.map(function(x){return x.entry}));

		if (!completely_winnable(playerPokes, pokes)) {
			break;
		}
		prev = pokes;
		rand_gap(lcg, shuu, i, rank);
	}
	if (i - 1 >= 4)
	console.log([seed, i - 1]);
}

function main1() {
	var ng_items = ["きあいのハチマキ", "せんせいのツメ", "きあいのタスキ", "ひかりのこな", "のんきのおこう"];
	var ng_abilities = ["ゆうばく", "ほのおのからだ", "ほうし", "トレース", "いかく"]
	var ng_abilities2 = ["ゆうばく"];
	// ムクホかラティの少なくとも一方で上から一撃で倒せる相手
	var mukuho = gen_poke(RANK_OPEN_8, true, factory_data[789], 0);
	var rathi = gen_poke(RANK_OPEN_8, true, factory_data[933], 0);
	var rai = gen_poke(RANK_OPEN_8, true, factory_data[788], 0);
	var brave = waza_fromname[mukuho.entry.move[0]];
	var ngs = [], num = 0;
	for (var i = 623; i <= 950; i ++) {
		var ret1 = check_1turn_ko(mukuho, i, brave, ng_items, ng_abilities);
		var ret2 = check_1turn_ko(rathi, i, null, ng_items, ng_abilities2);
		if (ret1 == "skipped" || ret2 == "skipped") continue;
		var ok = ret1 || ret2;
		if (!ok) ngs.push(i);
		num ++;
	}
	console.log(ngs.length+" / "+num);
}


function cw2(seed) {
	var lv = false, shuu = 1;
	var ibui   = gen_poke(starter_rank(false, 1), factory_data[64], 1);
	var eipamu = gen_poke(starter_rank(false, 1), factory_data[105], 0);
	var eneko  = gen_poke(starter_rank(false, 1), factory_data[116], 0);
	var patiru = gen_poke(starter_rank(false, 1), factory_data[108], 0);
	var koiru  = gen_poke(starter_rank(false, 1), factory_data[59], 0);
	var hitode = gen_poke(starter_rank(false, 1), factory_data[85], 0);
	var nuke   = gen_poke(starter_rank(false, 1), factory_data[16], 0);
	var mys = [ibui, eipamu, hitode];
	var lcg = new LCG(seed);
	var foes = rand_enemy_poke(lcg, trainer_rank(false, 1), mys.map(function(x){return x.entry}));
	return completely_winnable(mys, foes);
}

function cw(seed) {
	var mukuho = gen_poke(starter_rank(true, 5), factory_data[789], 0);
	var rathi  = gen_poke(starter_rank(true, 5), factory_data[933], 0);
	var maji   = gen_poke(starter_rank(true, 5), factory_data[821], 0);
	var mys = [mukuho, rathi, maji];
	var lcg = new LCG(seed);
	var foes = rand_enemy_poke(lcg, trainer_rank(true, 5), [mukuho, rathi, maji].map(function(x){return x.entry}));
	return completely_winnable(mys, foes);
}

// TODO: - 相手のダメージ技を考慮に入れる
function completely_winnable(mys, foes) {
	var ng_items = ["きあいのハチマキ", "せんせいのツメ", "きあいのタスキ", "ひかりのこな", "のんきのおこう"];
	var ng_abilities = [
		["ゆうばく", "ほのおのからだ", "ほうし"],
		["ゆうばく"],
		[]
	];
	var ng_waza = ["こらえる"];
	var ng_waza2 = ["りゅうのまい", "トリックルーム", "めいそう", "のろい", "ひかりのかべ", "リフレクター", "かげぶんしん", "ちいさくなる"];
	var ng_waza3_code = ["さいみんじゅつ", "どくばり", "ほのおのパンチ", "れいとうパンチ", "かみなりパンチ", "ふきとばし", "どくどく", "ひかりのかべ", "トライアタック", "ほのおのうず", "あやしいひかり", "こうそくいどう", "こわいかお", "リフレクター", "でんじは", "こごえるかぜ", "ばくれつパンチ", "みがわり", "やどりぎのタネ", "かなしばり", "アンコール", "うらみ", "でんこうせっか", "まきびし", "ほろびのうた", "すなあらし", "いばる", "メロメロ", "バトンタッチ", "みらいよち", "かみなり", "いちゃもん", "おにび", "ちょうはつ", "トリック", "あくび", "ブレイズキック", "どくどくのキバ", "ポイズンテール", "りゅうのまい", "つぼをつく", "とんぼがえり", "どくびし", "フレアドライブ", "トリックルーム", "うずしお", "ステルスロック", "ほのおのキバ", "こおりのキバ", "かみなりのキバ"].map(function(x){return waza_fromname[x].effectCode;});
	//console.log(foes.map(function(x) { return x.entry.id }));
	show_damage_table(mys, foes);

	if (foes.some(function(x) { return ng_items.indexOf(x.item) >= 0 })) {
		return false;
	}
	if (foes.some(function(x) { return x.waza.some(function(w) { return ng_waza.indexOf(w) >= 0 }) })) {
		return false;
	}

	var myHps = mys.map(function(x) { return x.hp });
	var curr = 0;
	var foeHps = foes.map(function(x) { return x.hp });
	var foeCurr = 0;
	var fixedWaza = null;
	var justAfterFoeExchanged = true;
	var atkMod = 0;
	var history = [];

	var stack = [];

	return winnable();

	function stackPush() {
		stack.push({
			myHps: myHps.slice(0),
			curr: curr,
			foeHps: foeHps.slice(0),
			foeCurr: foeCurr,
			fixedWaza: fixedWaza,
			justAfterFoeExchanged: justAfterFoeExchanged,
			atkMod: atkMod,
			history: history.slice(0)
		});
		justAfterFoeExchanged = false;
	}
	function stackPop() {
		var popped = stack.pop();
		myHps = popped.myHps;
		curr = popped.curr;
		foeHps = popped.foeHps;
		foeCurr = popped.foeCurr;
		fixedWaza = popped.fixedWaza;
		justAfterFoeExchanged = popped.justAfterFoeExchanged;
		atkMod = popped.atkMod;
		history  = popped.history;
	}
	function winnable() {
		//console.log([myHps.join(","), curr, foeHps.join(","), foeCurr, history.join(",")]);
		var my = mys[curr];
		var foe = foes[foeCurr];
		if (myHps.every(function(x) { return x <= 0 })) {
			return false;
		}
		if (foeHps.every(function(x) { return x <= 0 })) {
			return history;
		}
		// 現在HPが0→交換
		if (myHps[curr] <= 0) {
			var change = [0,1,2].filter(function(x){return myHps[x] > 0});
			for (var i of change) {
				stackPush();
				curr = i, fixedWaza = null, atkMod = 0;
				var r = winnable();
				stackPop();
				if (r) return r;
			}
			return false;
		}
		if (foeHps[foeCurr] <= 0) {
			var change = [0,1,2].filter(function(x){return foeHps[x] > 0});
			var r;
			for (var i of change) {
				stackPush();
				foeCurr = i;
				justAfterFoeExchanged = true;
				var r = winnable();
				stackPop();
				if (!r) return false;
			}
			return r;
		}
		if (justAfterFoeExchanged && (foe.ability == "いかく" || (my.ability == "いかく" && foe.ability == "トレース"))) {
			atkMod -= 1;
		}
		// たたかう場合
		if (calcComputedSpeed(my) <= calcComputedSpeed(foe)) {
			// 素早さ負ける→落ちて次のポケモンへ
			stackPush();
			myHps[curr] = 0;
			var ret = winnable();
			stackPop();
			if (ret) return ret;
		} else {
			var ret = action();
			if (ret) return ret;
		}
		// 交換する場合→交換先は倒れる

		// 相手が積み技などを持っていた場合
		if (foe.waza.some(function(x) { return ng_waza2.indexOf(x) >= 0 })) {
			return false;
		}
		var change = [0,1,2].filter(function(x){return myHps[x] > 0 && x != curr});
		for (var i = 0; i < change.length; i ++) {
			var c = change[i];
			stackPush();
			myHps[c] = 0;
			if (mys[c].item == "きあいのタスキ" && myHps[c] == mys[c].hp && foe.waza.every(function(w){return ng_waza3_code.indexOf(w.effectCode) < 0})) {
				myHps[c] = 1;
			}
			curr = change[i];
			fixedWaza = null, atkMod = 0;
			history.push(mys[change[i]].name+"に交代");
			var ret = winnable();
			stackPop();
			if (ret) return ret;
		}
		return false;
	}

	function action() {
		var my = mys[curr];
		var foe = foes[foeCurr];
		// 敵が先制攻撃技持ち
		var senseiWaza = foe.waza.find(function(w){return waza_fromname[w].priority == 1});
		var myDmg = 0;
		if (senseiWaza) {
			myDmg = calcDamage(foe, my, waza_fromname[senseiWaza], {max: true});
			if (myHps[curr] <= myDmg) {
				stackPush();
				myHps[curr] -= myDmg;
				var r = winnable();
				stackPop();
				return r;
			}
		}
		if (my.waza.indexOf("みちづれ") >= 0 && foe.waza.every(function(w){return ng_waza3_code.indexOf(waza_fromname[w].effectCode) < 0})) {
			stackPush();
			myHps[curr] = 0;
			foeHps[foeCurr] = 0;
			history.push(my.name+"で"+foe.name+"にみちづれ");
			var r = winnable();
			stackPop();
			if (r) {
				return r;
			}
		}
		var dmg = 0;
		var waza;
		if (fixedWaza) {
			waza = fixedWaza;
			dmg = calcDamage(my, foe, waza, {atkMod: atkMod});
		} else {
			// 一番ダメージの与えられる技を選択
			my.waza.forEach(function (wn) {
				var w = waza_fromname[wn];
				if (w.basePower > 1 && w.accuracy == 100) {
					var d = Math.min(calcDamage(my, foe, w, {atkMod: atkMod}), foeHps[foeCurr]);
					if (dmg < d) {
						dmg = d;
						waza = w;
					}
				}
			});
		}
		if (!waza) waza = waza_fromname["はねる"];
		var newHp = Math.max(foeHps[foeCurr] - dmg, 0);
		// 攻撃したときダメな特性だったら失敗とする
		if (ng_abilities[curr].indexOf(foe.ability) >= 0) {
			return false;
		}
		// 相手のHPが残っていて積み技などを持っていた場合失敗
		if (newHp > 0 && foe.waza.some(function(x) { return ng_waza2.indexOf(x) >= 0 })) {
			return false;
		}
		stackPush();
		myHps[curr] -= myDmg;
		if (waza.name == "ブレイブバード") {
			myHps[curr] -= int(dmg/3);
		}
		if (my.item == "こだわりハチマキ") {
			fixedWaza = waza;
		}
		foeHps[foeCurr] = newHp;
		if (newHp > 0) { // 相手のHPが残っている
			myHps[curr] = 0;
		}
		if (senseiWaza) {
			history.push(foe.name+"が"+my.name+"に"+senseiWaza+"("+myDmg+")");
		}
		history.push(my.name+"で"+foe.name+"に"+waza.name+"("+dmg+")");
		var ret = winnable();
		stackPop();
		return ret;
	}
}

function show_damage_table(mys, foes) {
	[mys, foes].forEach (function (pokes) {
		console.table(pokes.map (function (poke) {
			return [poke.name, poke.item, poke.ability, poke.entry.effort, ...poke.waza, poke.hp];
		}));
	});
	var table = [];
	mys.forEach (function (my) {
		var obj = {};
		obj["my"] = my.name;
		foes.forEach (function (foe) {
			var cell = calcComputedSpeed(foe) < calcComputedSpeed(my) ? "先制" : "後攻";
			var [dmg, waza] = damageAllWaza(my, foe, false);
			cell += " " + int(dmg / foe.hp * 100) + "% ("+waza.name+")";
			var [dmg2, waza2] = damageAllWaza(foe, my, true);
			cell += " " + int(dmg2 / my.hp * 100) + "% ("+waza2.name+")";
			obj[foe.name] = cell;
		});
		table.push(obj);
	});
	console.table(table);
}

function damageAllWaza(my, foe, max) {
	var dmg = 0;
	var waza;
	my.waza.forEach(function (wn) {
		var w = waza_fromname[wn];
		var d = calcDamage(my, foe, w, {max: max});
		if (dmg < d) {
			dmg = d;
			waza = w;
		}
	});
	return [dmg, waza];
}

function check_1turn_ko(my, entryid, fixedWaza, ng_items, ng_abilities) {
	var target = gen_poke(RANK_OPEN_8, true, factory_data[entryid], 0);
	if (target.item == my.item || target.name == my.name) {
		return "skipped";
	}
	var dmg = 0;
	if (fixedWaza) {
		dmg = damage(my, fixedWaza, entryid);
	} else {
		my.entry.move.forEach (function (waza) {
			dmg = Math.max(dmg, damage(my, waza_fromname[waza], entryid));
		});
	}
	var damageOk = dmg >= target.hp;

	var speedOk = calcComputedSpeed(target) < calcComputedSpeed(my);
	var itemOk = ng_items.indexOf(target.item) < 0;
	var badAbility = target.entry.pokemon.abilities.filter(function(x) { return ng_abilities.indexOf(x) >= 0 });
	var abilityOk = badAbility.length == 0;
	var ok = speedOk && damageOk && itemOk && abilityOk;

	var msg = target.name+":";
	msg += (speedOk ? "" : " speedNG("+calcComputedSpeed(target)+")");
	msg += (damageOk ? "" : " damageNG("+dmg+" / "+target.hp+")");
	msg += (itemOk ? "" : " itemNG("+target.item+")");
	msg += (abilityOk ? "" : " abilityNG("+badAbility.join(",")+")");
	msg += (ok ? " OK" : "");

	return ok;
}

function damage(userPoke, waza, index) {
	// 2つの特性両方を試す
	var target = gen_poke(RANK_OPEN_8, true, factory_data[index], 0);
	var dmg1 = calcDamage(userPoke, target, waza);
	var target = gen_poke(RANK_OPEN_8, true, factory_data[index], 1);
	var dmg2 = calcDamage(userPoke, target, waza);
	return Math.min(dmg1, dmg2);
}

</script>
</head>
<body>
</body>
</html>
