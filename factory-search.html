<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>factory-search</title>
<script src="jquery.js"></script>
<script src="factory-data.js"></script>
<script src="lcg.js"></script>
<script src="factory2.js"></script>
<script src="damage.js"></script>
<script>
$(function () {
	initialize_factory(function () {
		var lcg = new LCG(0);
		var shuu = 5;
		var is_open_level = true;
		var entries = rand_starter_entries(lcg, is_open_level, shuu, 0);
		var starters = starter_entiries_to_poke(is_open_level, shuu, 0, entries, rand_pid(lcg, entries));
		var playerPokes = starters.slice(0, 3);
		console.log(starters.map(function(x){return x.name}));
		lcg.step(2); // shuffle
		var enemyRank = Rank.objectsOpenTrainer[5];
		rand_enemy_loop(lcg, shuu, enemyRank, starters, playerPokes, function (i, enemy) {
			console.log(enemy.map(function(x){return x.name}));
		});
	});
});

function main0() {
	var info = get_6_entries_info(5, true, 0, 0);
	console.log(info.entries.map(function(x) {return x.name}));
	var info2 = get_3_entries_info(fix_rank_enemy(5, true), info.seed, info.entries);
	console.log(info2.entries.map(function(x) {return x.name}));
	var seed = step_seed(info2.seed, get_enemy_consuption(5, 1, 5));
	var info3 = get_3_entries_info(fix_rank_enemy(5, true), seed, info.entries.slice(0, 3).concat(info2.entries));
	console.log(info3.entries.map(function(x) {return x.name}));
}
function main1() {
	var ng_items = ["きあいのハチマキ", "せんせいのツメ", "きあいのタスキ", "ひかりのこな", "のんきのおこう"];
	var ng_abilities = ["ゆうばく", "ほのおのからだ", "ほうし", "トレース", "いかく"]
	var ng_abilities2 = ["ゆうばく"];
	// ムクホかラティの少なくとも一方で上から一撃で倒せる相手
	var mukuho = gen_poke(RANK_OPEN_8, true, factory_data[789], 0);
	var rathi = gen_poke(RANK_OPEN_8, true, factory_data[933], 0);
	var rai = gen_poke(RANK_OPEN_8, true, factory_data[788], 0);
	var brave = waza_fromname[mukuho.entry.move[0]];
	var ngs = [], num = 0;
	for (var i = 623; i <= 950; i ++) {
		var ret1 = check_1turn_ko(mukuho, i, brave, ng_items, ng_abilities);
		var ret2 = check_1turn_ko(rathi, i, null, ng_items, ng_abilities2);
		if (ret1 == "skipped" || ret2 == "skipped") continue;
		var ok = ret1 || ret2;
		if (!ok) ngs.push(i);
		num ++;
	}
	console.log(ngs.length+" / "+num);
}

// TODO: - 相手のダメージ技を考慮に入れる
function completely_winnable(seed) {
	var ng_items = ["きあいのハチマキ", "せんせいのツメ", "きあいのタスキ", "ひかりのこな", "のんきのおこう"];
	var ng_abilities = [
		["ゆうばく", "ほのおのからだ", "ほうし"],
		["ゆうばく"],
		[]
	];
	var ng_waza = ["こらえる", "でんこうせっか", "マッハパンチ", "しんそく", "ねこだまし", "ふいうち", "しんくうは", "バレットパンチ", "こおりのつぶて", "かげうち", "アクアジェット"];
	var ng_waza2 = ["りゅうのまい", "トリックルーム", "めいそう", "のろい", "ひかりのかべ", "リフレクター", "かげぶんしん", "ちいさくなる"];
	var mukuho = gen_poke(RANK_OPEN_8, true, factory_data[789], 0);
	var rathi = gen_poke(RANK_OPEN_8, true, factory_data[933], 0);
	var suke = gen_poke(RANK_OPEN_8, true, factory_data[839], 0);
	var mys = [mukuho, rathi, suke];
	var foes = gen_enemy_pokes(RANK_OPEN_8, true, seed, mys);
	//console.log(foes.map(function(x) { return x.name }));

	if (foes.some(function(x) { return ng_items.indexOf(x.item) >= 0 })) {
		return false;
	}
	if (foes.some(function(x) { return x.waza.some(function(w) { return ng_waza.indexOf(w) >= 0 }) })) {
		return false;
	}


	var myHps = mys.map(function(x) { return x.hp });
	var curr = 0;
	var foeHps = foes.map(function(x) { return x.hp });
	var foeCurr = 0;
	var fixedWaza = null;
	var justAfterFoeExchanged = true;
	var atkMod = 0;
	var history = [];

	var stack = [];

	return winnable();

	function stackPush() {
		stack.push({
			myHps: myHps.slice(0),
			curr: curr,
			foeHps: foeHps.slice(0),
			foeCurr: foeCurr,
			fixedWaza: fixedWaza,
			justAfterFoeExchanged: justAfterFoeExchanged,
			atkMod: atkMod,
			history: history.slice(0)
		});
		justAfterFoeExchanged = false;
	}
	function stackPop() {
		var popped = stack.pop();
		myHps = popped.myHps;
		curr = popped.curr;
		foeHps = popped.foeHps;
		foeCurr = popped.foeCurr;
		fixedWaza = popped.fixedWaza;
		justAfterFoeExchanged = popped.justAfterFoeExchanged;
		atkMod = popped.atkMod;
		history  = popped.history;
	}
	function winnable() {
		//console.log([myHps.join(","), curr, foeHps.join(","), foeCurr, history.join(",")]);
		var my = mys[curr];
		var foe = foes[foeCurr];
		if (myHps.every(function(x) { return x <= 0 })) {
			return false;
		}
		if (foeHps.every(function(x) { return x <= 0 })) {
			return history;
		}
		// 現在HPが0→交換
		if (myHps[curr] <= 0) {
			var change = [0,1,2].filter(function(x){return myHps[x] > 0});
			for (var i of change) {
				stackPush();
				curr = i, fixedWaza = null, atkMod = 0;
				var r = winnable();
				stackPop();
				if (r) return r;
			}
			return false;
		}
		if (foeHps[foeCurr] <= 0) {
			var change = [0,1,2].filter(function(x){return foeHps[x] > 0});
			var r;
			for (var i of change) {
				stackPush();
				foeCurr = i;
				justAfterFoeExchanged = true;
				var r = winnable();
				stackPop();
				if (!r) return false;
			}
			return r;
		}
		if (justAfterFoeExchanged && (foe.ability == "いかく" || (my.ability == "いかく" && foe.ability == "トレース"))) {
			atkMod -= 1;
		}
		// たたかう場合
		if (calcComputedSpeed(my) <= calcComputedSpeed(foe)) {
			// 素早さ負ける→落ちて次のポケモンへ
			stackPush();
			myHps[curr] = 0;
			var ret = winnable();
			stackPop();
			if (ret) return ret;
		} else {
			var ret = action();
			if (ret) return ret;
		}
		// 交換する場合→交換先は倒れる

		// 相手が積み技などを持っていた場合
		if (foe.waza.some(function(x) { return ng_waza2.indexOf(x) >= 0 })) {
			return false;
		}
		var change = [0,1,2].filter(function(x){return myHps[x] > 0 && x != curr});
		for (var i = 0; i < change.length; i ++) {
			stackPush();
			myHps[change[i]] = 0;
			curr = change[i];
			fixedWaza = null, atkMod = 0;
			history.push(mys[change[i]].name+"に交代");
			var ret = winnable();
			stackPop();
			if (ret) return ret;
		}
		return false;
	}

	function action() {
		var my = mys[curr];
		var foe = foes[foeCurr];
		var dmg = 0;
		var waza;
		if (fixedWaza) {
			waza = fixedWaza;
			dmg = calcDamage(my, foe, waza, {atkMod: atkMod});
		} else {
			// 一番ダメージの与えられる技を選択
			my.waza.forEach(function (wn) {
				var w = waza_fromname[wn];
				if (w.basePower > 1 && w.accuracy == 100) {
					var d = Math.min(calcDamage(my, foe, w, {atkMod: atkMod}), foeHps[foeCurr]);
					if (dmg < d) {
						dmg = d;
						waza = w;
					}
				}
			});
		}
		var newHp = Math.max(foeHps[foeCurr] - dmg, 0);
		// 攻撃したときダメな特性だったら失敗とする
		if (ng_abilities[curr].indexOf(foe.ability) >= 0) {
			return false;
		}
		// 相手のHPが残っていて積み技などを持っていた場合失敗
		if (newHp > 0 && foe.waza.some(function(x) { return ng_waza2.indexOf(x) >= 0 })) {
			return false;
		}
		stackPush();
		if (waza.name == "ブレイブバード") {
			myHps[curr] -= int(dmg/3);
		}
		if (my.item == "こだわりハチマキ") {
			fixedWaza = waza;
		}
		foeHps[foeCurr] = newHp;
		if (newHp > 0) { // 相手のHPが残っている
			myHps[curr] = 0;
		}
		history.push(my.name+"で"+foe.name+"に"+waza.name+"("+dmg+")");
		var ret = winnable();
		stackPop();
		return ret;
	}
}

function check_1turn_ko(my, entryid, fixedWaza, ng_items, ng_abilities) {
	var target = gen_poke(RANK_OPEN_8, true, factory_data[entryid], 0);
	if (target.item == my.item || target.name == my.name) {
		return "skipped";
	}
	var dmg = 0;
	if (fixedWaza) {
		dmg = damage(my, fixedWaza, entryid);
	} else {
		my.entry.move.forEach (function (waza) {
			dmg = Math.max(dmg, damage(my, waza_fromname[waza], entryid));
		});
	}
	var damageOk = dmg >= target.hp;

	var speedOk = calcComputedSpeed(target) < calcComputedSpeed(my);
	var itemOk = ng_items.indexOf(target.item) < 0;
	var badAbility = target.entry.pokemon.abilities.filter(function(x) { return ng_abilities.indexOf(x) >= 0 });
	var abilityOk = badAbility.length == 0;
	var ok = speedOk && damageOk && itemOk && abilityOk;

	var msg = target.name+":";
	msg += (speedOk ? "" : " speedNG("+calcComputedSpeed(target)+")");
	msg += (damageOk ? "" : " damageNG("+dmg+" / "+target.hp+")");
	msg += (itemOk ? "" : " itemNG("+target.item+")");
	msg += (abilityOk ? "" : " abilityNG("+badAbility.join(",")+")");
	msg += (ok ? " OK" : "");

	return ok;
}

function damage(userPoke, waza, index) {
	// 2つの特性両方を試す
	var target = gen_poke(RANK_OPEN_8, true, factory_data[index], 0);
	var dmg1 = calcDamage(userPoke, target, waza);
	var target = gen_poke(RANK_OPEN_8, true, factory_data[index], 1);
	var dmg2 = calcDamage(userPoke, target, waza);
	return Math.min(dmg1, dmg2);
}

</script>
</head>
<body>
</body>
</html>
