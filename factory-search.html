<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>factory-search</title>
<script src="jquery.js"></script>
<script src="factory-data.js"></script>
<script src="lcg.js"></script>
<script src="factory.js"></script>
<script src="damage.js"></script>
<script>
$(function () {
	initialize_factory(function () {
		main_search_seed(judge_seed_lv50_shuu2);
	});
});

function main_search_seed(judge_seed) {
	var i = 0;
	function loop() {
		document.title = hex(i);
		while (true) {
			if (i > 0xffffffff) {
				console.log("finish");
				return;
			}
			if (judge_seed(i ++)) return;
			if ((i & 0xffff) == 0) break;
		}
		setTimeout(loop, 0);
	}
	loop();
}

function judge_seed_open_shuu4(seed) {
	var lcg = new LCG(seed);
	var shuu = 4;
	var is_open_level = true;
	var is_hgss = true;
	var trainers = rand_trainers(lcg, shuu, is_hgss);
	var entries = rand_starter_entries(lcg, is_open_level, shuu, 0);
	var mukuho_idx = entries.map(function(x){return x.id}).indexOf(789);
	//var rathi_idx = entries.map(function(x){return x.id}).indexOf(933);
	var maji_idx = entries.map(function(x){return x.id}).indexOf(821);
	if (mukuho_idx < 0 || maji_idx < 0) return;
	var starters = starter_entiries_to_poke(is_open_level, shuu, 0, entries, rand_pid(lcg, entries));
	var mukuho = starters[mukuho_idx];
	//var rathi = starters[rathi_idx];
	var maji = starters[maji_idx];
	lcg.step(2); // shuffle
	var nodbg = true;
	var ng_abilities = [
		["ゆうばく", "ほのおのからだ", "ほうし"],
		["ゆうばく"],
		[]
	]
	for (var idx = 0; idx < 6; idx ++) {
		var l = new LCG(lcg.seed);
		if (idx == mukuho_idx || idx == maji_idx) continue;
		var suke = starters[idx];
		var playerPokes = [mukuho, maji, suke];

		if (!nodbg) console.table(playerPokes.map (function (poke) {
			return [poke.name, poke.item, poke.ability, poke.entry.effort, ...poke.waza, poke.hp];
		}));
		var prev;
		for (var i = 1; i <= 7; i ++) {
			var seen = i == 1 ? starters : playerPokes.concat(prev);
			var rank = trainer_id_to_rank(is_open_level, is_hgss, trainers[i-1]);
			var pokes = rand_enemy_poke(l, rank, seen.map(function(x){return x.entry}));

			if (!nodbg) console.log(i);
			var ret = completely_winnable(playerPokes, pokes, ng_abilities, nodbg);
			if (!ret) {
				break;
			}
			if (!nodbg) ret.forEach((r) => console.log(r));
			prev = pokes;
			rand_gap(l, shuu, i, rank);
		}
		if (i - 1 >= 7) {
			console.log([seed, idx, i - 1, suke.name + "("+suke.item+")"]);
		}
	}
}

function judge_seed_lv50_shuu1(seed) {
	var lcg = new LCG(seed);
	var shuu = 1;
	var is_open_level = false;
	var is_hgss = false;
	var trainers = rand_trainers(lcg, shuu, is_hgss);
	var entries = rand_starter_entries(lcg, is_open_level, shuu, 0);
	var kutit_idx = entries.map(function(x){return x.id}).indexOf(118);
	var nuke_idx = entries.map(function(x){return x.id}).indexOf(16);
	if (kutit_idx < 0 || nuke_idx < 0) return;
	var starters = starter_entiries_to_poke(is_open_level, shuu, 0, entries, rand_pid(lcg, entries));
	var kutit = starters[kutit_idx];
	var nuke = starters[nuke_idx];
	lcg.step(2); // shuffle
	var nodbg = true;
	for (var idx = 0; idx < 6; idx ++) {
		var l = new LCG(lcg.seed);
		if (idx == kutit_idx || idx == nuke_idx) continue;
		var suke_first = starters[idx];
		var sukes = [suke_first];
		var playerPokes = [kutit, nuke, suke_first];
		var hist;
		if (hist = judge(1, lcg.seed, null, playerPokes, starters, null)) {
			console.log([seed, [suke_first].concat(hist).map(x => x.name)]);
			return true;
		}
	}
	return false;

	function judge(i, seed, oldPlayerPokes, playerPokes, starters, prev) {
		if (i == 8) return [];
		
		var lcg = new LCG(seed);
		var seen = i == 1 ? starters : oldPlayerPokes.concat(prev);
		var rank = trainer_id_to_rank(is_open_level, is_hgss, trainers[i-1]);
		var pokes = rand_enemy_poke(lcg, rank, seen.map(function(x){return x.entry}));
		var ret = winnable2(playerPokes, pokes);
		if (ret) {
			rand_gap(lcg, shuu, i, rank);
			for (var j = 0; j < 3; j ++) {
				var newPlayerPokes = playerPokes.concat();
				newPlayerPokes[2] = pokes[j];
				var hist;
				if (hist = judge(i + 1, lcg.seed, playerPokes, newPlayerPokes, starters, pokes)) {
					return [pokes[j]].concat(hist);
				}
			}
		} else {
			return false;
		}
	}
}

function winnable2(playerPokes, pokes) {
	var ng_pokes = ["タテトプス", "ゴローン", "ポワルン", "パラセクト"];
	var ng_waza_code = ["すなあらし"]
	  .map((x) => waza_fromname[x].effectCode);	
	if (pokes.some(poke => ng_pokes.indexOf(poke.name) >= 0 )) return false;
	if (pokes.some(poke => poke.waza.some(w => ng_waza_code.indexOf(waza_fromname[w].effectCode) >= 0 ))) return false;
	var count = 0;
	var count2 = 0;
	for(var i = 0; i < pokes.length; i ++) {
		var poke = pokes[i];
		if (is_weaker(playerPokes[0], poke, 0.5) || is_weaker_than_nukenin(poke) || is_weaker(playerPokes[2], poke, 0.5)) count ++;
		if (is_weaker_than_nukenin(poke)) count2 ++;
	}
	return count2 >= 1 && pokes.length <= count;
}

function judge_seed_lv50_shuu2(seed) {
	var lcg = new LCG(seed);
	var shuu = 2;
	var is_open_level = false;
	var is_hgss = false;
	var num_bonus = 1;
	var trainers = rand_trainers(lcg, shuu, is_hgss);
	var entries = rand_starter_entries(lcg, is_open_level, shuu, num_bonus);
	var suba_idx = entries.map(function(x){return x.id}).indexOf(289);
	if (suba_idx < 0) return;
	var starters = starter_entiries_to_poke(is_open_level, shuu, 0, entries, rand_pid(lcg, entries));
	var suba = starters[suba_idx];
	lcg.step(2); // shuffle
	console.log(seed);
	return true;
}

function main2() {
	var rank = starter_rank(false, 1);
	var data = factory_data.slice(1, 1 + 150);
	//data = factory_data.slice(151, 151 + 100);
	var kuti = gen_poke(rank, factory_data[118], 0);
	data = data.filter((entry) => { return is_weaker(kuti, gen_poke(rank, entry, 0), 0.3) });
	var table = data.map(x => {return "<tr><td>" + x.id + "<td>" + x.name + "<td>" + x.item + "<td>" + x.move.join(" ") +
	"<td>" + x.pokemon.abilities[0] + "<td>" + (x.pokemon.abilities[0] == x.pokemon.abilities[1] ? "-" : x.pokemon.abilities[1]) +
	"<td>" + x.pokemon.stats.reduce((x,y)=>x+y, 0) + "<td>" + get_status(trainer_rank(false, 1), x)[5]}).join("")
	document.body.innerHTML = "<h2>hoge</h2><table>" + table +"</table>"
}

// 攻撃技を打ち合ったとき自分が勝ってHPがthreshold倍以上残るか (テキトー)
function is_weaker(my, foe, threshold) {
	var damageToFoe = damageAllWaza(my, foe, {ignoreAccuracy: true})[0];
	var damageToMy = damageAllWaza(foe, my, {ignoreAccuracy: true})[0];
	var turn = Math.ceil(foe.hp / damageToFoe);
	if (calcComputedSpeed(my) <= calcComputedSpeed(foe)) {
		turn ++;
	}
	return turn * damageToMy < my.hp * threshold;
}

function is_weaker_than_nukenin(foe) {
	var ng_abilities = ["どくのトゲ", "ゆきふらし", "ほうし"];
	var ng_waza_code = ["あやしいひかり", "どくどく", "やどりぎのタネ", "なやみのタネ", "すなあらし", "おにび", "いばる", ]
	  .map((x) => { return waza_fromname[x].effectCode;});
	if (ng_abilities.indexOf(foe.ability) >= 0) {
		return false;
	}
	if (foe.waza.some((w) => { return ng_waza_code.indexOf(waza_fromname[w].effectCode) >= 0 })) {
		return false;
	}
	// むし・ゴーストに抜群な攻撃技を持っている
	if (foe.waza.some((w) => { return waza_fromname[w].basePower > 0 && typeChart(waza_fromname[w].type, "むし") * typeChart(waza_fromname[w].type, "ゴースト") > 1})) {
		return false;
	}
	return true;
}

// TODO: - 相手のダメージ技を考慮に入れる
function completely_winnable(mys, foes, ng_abilities, nodbg) {
	var ng_items = ["せんせいのツメ"];
	var ng_waza = ["こらえる"];
	// 交換する場合にされたら困る技
	var ng_waza2 = ["りゅうのまい", "トリックルーム", "めいそう", "のろい", "ひかりのかべ", "リフレクター", "かげぶんしん", "ちいさくなる"];
	// 道連れする場合にされたら困る技のコード
	var ng_waza3_code = ["さいみんじゅつ", "どくばり", "ほのおのパンチ", "れいとうパンチ", "かみなりパンチ", "ふきとばし", "どくどく", "ひかりのかべ", "トライアタック", "ほのおのうず", "あやしいひかり", "こうそくいどう", "こわいかお", "リフレクター", "でんじは", "こごえるかぜ", "ばくれつパンチ", "みがわり", "やどりぎのタネ", "かなしばり", "アンコール", "うらみ", "でんこうせっか", "まきびし", "ほろびのうた", "すなあらし", "いばる", "メロメロ", "バトンタッチ", "げんしのちから", "みらいよち", "かみなり", "あられ", "いちゃもん", "おにび", "ちょうはつ", "トリック", "あくび", "ブレイズキック", "どくどくのキバ", "ポイズンテール", "りゅうのまい", "つぼをつく", "とんぼがえり", "どくびし", "フレアドライブ", "トリックルーム", "うずしお", "ステルスロック", "ほのおのキバ", "こおりのキバ", "かみなりのキバ"].map(function(x){return waza_fromname[x].effectCode;});
	if (!nodbg) show_damage_table(mys, foes);

	if (foes.some(function(x) { return ng_items.indexOf(x.item) >= 0 })) {
		return false;
	}
	if (foes.some(function(x) { return x.waza.some(function(w) { return ng_waza.indexOf(w) >= 0 }) })) {
		return false;
	}

	var myHps = mys.map(function(x) { return x.hp });
	var curr = 0;
	var foeHps = foes.map(function(x) { return x.hp });
	var foeCurr = 0;
	var fixedWaza = null;
	var justAfterFoeExchanged = true;
	var atkMod = 0;
	var history = [];

	var stack = [];

	return winnable();

	function stackPush() {
		stack.push({
			myHps: myHps.slice(0),
			curr: curr,
			foeHps: foeHps.slice(0),
			foeCurr: foeCurr,
			fixedWaza: fixedWaza,
			justAfterFoeExchanged: justAfterFoeExchanged,
			atkMod: atkMod,
			history: history.slice(0)
		});
		justAfterFoeExchanged = false;
	}
	function stackPop() {
		var popped = stack.pop();
		myHps = popped.myHps;
		curr = popped.curr;
		foeHps = popped.foeHps;
		foeCurr = popped.foeCurr;
		fixedWaza = popped.fixedWaza;
		justAfterFoeExchanged = popped.justAfterFoeExchanged;
		atkMod = popped.atkMod;
		history  = popped.history;
	}
	function winnable() {
		//if (!nodbg) console.log("-".repeat(stack.length) + [myHps.join(","), curr, foeHps.join(","), foeCurr, history[history.length-1]].join(" "));
		var my = mys[curr];
		var foe = foes[foeCurr];
		if (myHps.every(function(x) { return x <= 0 })) {
			return false;
		}
		if (foeHps.every(function(x) { return x <= 0 })) {
			//if (!nodbg) console.log("-".repeat(stack.length) + "succeed");
			return history;
		}
		// 現在HPが0→交換
		if (myHps[curr] <= 0) {
			var change = [0,1,2].filter(function(x){return myHps[x] > 0});
			for (var i of change) {
				stackPush();
				curr = i, fixedWaza = null, atkMod = 0;
				history.push(mys[curr].name+"を繰り出す");
				var r = winnable();
				stackPop();
				if (r) return r;
			}
			return false;
		}
		if (foeHps[foeCurr] <= 0) {
			var change = [0,1,2].filter(function(x){return foeHps[x] > 0});
			var rs = []
			for (var i of change) {
				stackPush();
				foeCurr = i;
				justAfterFoeExchanged = true;
				var r = winnable();
				stackPop();
				if (!r) return false;
				rs.push(r);
			}
			if (rs.length == 1) return rs[0];
			return rs;
		}
		if (justAfterFoeExchanged && (foe.ability == "いかく" || (my.ability == "いかく" && foe.ability == "トレース"))) {
			atkMod -= 1;
		}
		// たたかう場合
		if (calcComputedSpeed(my) <= calcComputedSpeed(foe)) {
			// 素早さ負ける→落ちて次のポケモンへ
			stackPush();
			myHps[curr] = 0;
			var ret = winnable();
			stackPop();
			if (ret) return ret;
		} else {
			var ret = action();
			if (ret) return ret;
		}
		// 交換する場合→交換先は倒れる

		// 相手が積み技などを持っていた場合
		if (foe.waza.some(function(x) { return ng_waza2.indexOf(x) >= 0 })) {
			return false;
		}
		var change = [0,1,2].filter(function(x){return myHps[x] > 0 && x != curr});
		for (var i = 0; i < change.length; i ++) {
			var c = change[i];
			stackPush();
			if (mys[c].item == "きあいのタスキ" && myHps[c] == mys[c].hp && foe.waza.every(function(w){return ng_waza3_code.indexOf(waza_fromname[w].effectCode) < 0})) {
				myHps[c] = 1;
			} else {
				myHps[c] = 0;
			}
			curr = change[i];
			fixedWaza = null, atkMod = 0;
			history.push(mys[change[i]].name+"に交代");
			var ret = winnable();
			stackPop();
			if (ret) return ret;
		}
		return false;
	}

	function action() {
		var my = mys[curr];
		var foe = foes[foeCurr];
		// 敵が先制攻撃技持ち
		var senseiWaza = foe.waza.find(function(w){return waza_fromname[w].priority == 1});
		var myDmg = 0;
		if (senseiWaza) {
			myDmg = calcDamage(foe, my, waza_fromname[senseiWaza], {max: true});
			if (myHps[curr] <= myDmg) {
				stackPush();
				myHps[curr] -= myDmg;
				var r = winnable();
				stackPop();
				return r;
			}
		}
		if (my.waza.indexOf("みちづれ") >= 0 && foe.waza.every(function(w){return ng_waza3_code.indexOf(waza_fromname[w].effectCode) < 0})) {
			stackPush();
			myHps[curr] = 0;
			foeHps[foeCurr] = 0;
			history.push(my.name+"で"+foe.name+"にみちづれ");
			var r = winnable();
			stackPop();
			if (r) {
				return r;
			}
		}
		var dmg = 0;
		var waza;
		if (fixedWaza) {
			waza = fixedWaza;
			dmg = calcDamage(my, foe, waza, {atkMod: atkMod});
		} else {
			// 一番ダメージの与えられる技を選択
			my.waza.forEach(function (wn) {
				var w = waza_fromname[wn];
				if (w.basePower > 1 && w.accuracy == 100) {
					var d = Math.min(calcDamage(my, foe, w, {atkMod: atkMod}), foeHps[foeCurr]);
					if (dmg < d) {
						dmg = d;
						waza = w;
					}
				}
			});
		}
		if (!waza) waza = waza_fromname["はねる"];
		var newHp = Math.max(foeHps[foeCurr] - dmg, 0);
		// 攻撃したときダメな特性だったら失敗とする
		if (ng_abilities[curr].indexOf(foe.ability) >= 0) {
			return false;
		}
		// 相手のHPが残っていて積み技などを持っていた場合失敗
		if (newHp > 0 && foe.waza.some(function(x) { return ng_waza2.indexOf(x) >= 0 })) {
			return false;
		}
		stackPush();
		myHps[curr] -= myDmg;
		if (waza.name == "ブレイブバード") {
			myHps[curr] -= int(dmg/3);
		}
		if (my.item == "こだわりハチマキ") {
			fixedWaza = waza;
		}
		foeHps[foeCurr] = newHp;
		if (newHp > 0) { // 相手のHPが残っている
			myHps[curr] = 0;
		}
		if (senseiWaza) {
			history.push(foe.name+"が"+my.name+"に"+senseiWaza+"("+myDmg+")");
		}
		history.push(my.name+"で"+foe.name+"に"+waza.name+"("+dmg+")");
		var ret = winnable();
		stackPop();
		return ret;
	}
}

function damageAllWaza(my, foe, options) {
	var dmg = -1;
	var waza;
	my.waza.forEach(function (wn) {
		var w = waza_fromname[wn];
		var d = calcDamage(my, foe, w, options);
		if (dmg < d) {
			dmg = d;
			waza = w;
		}
	});
	return [dmg, waza];
}

</script>
</head>
<body>
</body>
</html>
